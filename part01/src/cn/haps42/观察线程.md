# 观察线程

可以通过**Jconsole**和**Jstack**命令来观察线程的运行情况。

![1557322707719](<https://github.com/19940610mxh666/java-concurrency-programming/raw/master/images/part01/1557323907231.png>)

# 线程的生命周期

## 线程的五个主要阶段

1. **NEW**：当我们用关键字new创建一个Thread对象时，此时它并**不处于执行状态**， 因为没有调用**start**方法启动该线程，那么线程的状态为 **NEW **状态，准确地说，它知识Thread对象的状态，因为在没有start之前，该线程根本不存在，与你用关键字new创建一个普通的对象没有什么区别。 **NEW**状态可以通过 **start**方法进入 **RUNNABLE**状态。

2. **RUNNABLE**：线程对象进入 **RUNNABLE**状态必须调用 **start**方法，那么此时才是真正地在JVM进程中创建了一个线程，线程一经启动就可以立即执行么？不是的，线程的运行与否和进程一样都要听令于CPU的调度，那么我们在这个中间状态称为可执行状态（ **RUNNABLE**），也就是说它具备执行的资格，但是没有真正地执行起来而是在等待CPU的调度。由于存在 **RUNNING**状态，所以不会直接进入 **BLOCKED**状态和 **TERMINATED**状态，即使是在线程的执行逻辑中调用wait，sleep或者其他block的IO操作等，也必须先获得CPU的调度执行权才可以。严格来讲， **RUNNABLE**的线程只能意外种植或者进入 **RUNNING** 状态。

3. **RUNNING**：一旦CPU通过轮询或者其他方式从任务可执行队列中选中了线程，那么此时他才能真正地执行自己的逻辑代码，需要说明的一点是一个正在 **RUNNING**状态的线程事实上也是 **RUNNABLE**的，但是反过来则不成立。在该状态中，线程的状态可以发生如下的状态装换。

   - 直接进入 **TERMINATED**状态，比如调用JDK已经不推荐使用的stop方法或判断某个逻辑标志。
   - 进入 **BLOCKED**状态。比如调用了sleep，或者wait方法而加入waitSet中。
   - 进行某个阻塞的IO操作，比如因网络数据的读写而进入了 **BLOCKED**状态。
   - 获取了某个锁资源，从而加入到该锁的阻塞队列中而进入了 **BLOCKED**状态。
   - 由于CPU的调度轮询使该线程放弃执行，进入 **RUNNABLE**状态。
   - 线程主动调用yield方法，放弃CPU执行，进入 **RUNNABLE**状态。

4. **BLOCKED**：线程阻塞状态，暂停执行。线程在 **BLOCKED**状态中可以切换至如下几个状态。

   - 直接进入 **TERMINTED**状态，比如调用了JDK已经不推荐的stop方法或者意外死亡（JVMcrash）。
   - 线程阻塞的操作结束，比如读取了想要的数据字节进入到 **RUNNABLE**状态。
   - 线程完成了指定时间的休眠，进入到了 **RUNNABLE**状态。
   - wait中国的线程被他线程notify/notifyall唤醒，进入到了 **RUNNABLE**状态。
   - 线程获取到了某个锁资源，进入到了 **RUNNABLE**状态。
   - 线程在阻塞过程中被打断，比如其它线程调用了interrupt方法，进入到了 **RUNNABLE**状态。

5. **TERMINATED**：是线程的最终状态。在该状态中线程不会切换到其它任何状态，线程进入到 **TERMINARED**状态，意味着该线程的整个生命周期都结束了。下列情况将会使线程进入 **TERMINATED**状态。

   - 线程运行正常结束，结束生命周期。

   - 线程运行出错意外结束。

   - JVMcrash，导致所有线程结束。
# 线程的start方法剖析：模板设计模式在Thread中的应用


